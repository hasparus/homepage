---
title: Unreliable LLMs vs the Community
---

<Callout icon="✍️">
  **Epistemic Effort:** I wrote this very fast, and I'm not an AI expert.
</Callout>

I'm worried that @GitHubNext's Copilot Chat will make software engineering
harder to learn, not easier. Even if not, they can make it more of a lonesome
experience.

Asking an unreliable LLM for advice instead of googling for a GitHub issue, or a
StackOverflow answer, might be super dangerous because **LLMs [confabulate]!**

[confabulate]: https://www.beren.io/2023-03-19-LLMs-confabulate-not-hallucinate/

When I paste an error message into the searchbar, I have an idea of what I'm
looking for. It's either:

1. An issue in the repository of the library that threw the error, preferably
   with the maintainer's answer I can use to quickly work around the problem.

2. A post by people I trust, like @TitianCernicova, @AndaristRake, @joebell\_
   and many others.

I don't have to validate that hard, because I know those people. I know they've
helped me multiple times over the last 9 years, and I recognize them as people
who know what they're doing.

Over the years of their career, software engineers start to recognize GitHub
handles and avatars of other people in the industry.

An artisan on their journey to mastery meets people to learn from, some master
craftsmen of old, but also people on their level of experience, who encountered
the same error message just yesterday!

In this, the industry is very social, **community-driven**.

<aside>

We can call it parasocial, but it's still more social than a genie behind the
glass.

</aside>

It's nice to see the avatars you know solving the same technical challenges you
face right now. we're social animals. Following the path of another human being
always feels safer than trailblazing a new one. It's extra nice if you get to
meet one of the people you know from GitHub on a conference or a local tech
meetup.

When I google for a solution, I’m looking at Medium and devto posts last,
because I very rarely find anything helpful in them. It's super easy to write
some bullshit that doesn't even work and call it a best practice.

Software engineering is very often a practice of patience and curiosity. You
read your codebase, search the internet, delve deep into node_modules, time
travel through somebody else's GitHub history.

And then you validate.

LLMs can lead us to a world with way less searching, but way more validation.
You can't trust the genie, because it's not risking its personal brand and
credibility.

Can we combine them with static analysis tooling and AI-generated test harnesses
to make the validation easier? Can we limit AI confabulation? Can we build
AI-powered analysis tooling to help our validation and eliminate ourselves from
the process? Surely yes, with time.

But won't this slowly lead us to the world where we don't need the middle class
of software craftsmen, and we all become BigCo product owners shamans
orchestrating an army of machines or indie businessmen trying to carve out our
little niches? Competing with each other instead of collaborating?

It sounds lonely, doesn't it?

<figure>

> Think about the first language you ever loved [...] That profound satisfaction
> when the bug is dead and logic triumphs again. The pride of creation.
>
> Yeah, you were lucky enough to live in that world, and if you were in the
> right place at the right time you even got paid unimaginable amounts of money
> to do it. How will you feel when it’s all over?

<figcaption>

<div class="p-1" />

—Forrest Brazeal:
[When programming is gone, will we like what's left?](https://newsletter.goodtechthings.com/p/when-programming-is-gone-will-we)

</figcaption>
</figure>
